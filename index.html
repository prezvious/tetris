<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    :root {
      /* Pastel Color Palette */
      --pastel-pink: #FFD1DC;
      --pastel-blue: #AEC6CF;
      --pastel-mint: #B5EAD7;
      --pastel-lavender: #E0BBE4;
      --pastel-peach: #FFDAB9;
      --pastel-yellow: #FFFACD;
      --pastel-coral: #FFB7B2;

      /* Tetromino Colors - Soft Pastels */
      --cyan-pastel: #A8E6CF;
      --blue-pastel: #9BB8ED;
      --orange-pastel: #FFD4A3;
      --yellow-pastel: #FFF4B8;
      --green-pastel: #C7EECF;
      --purple-pastel: #D4A5E8;
      --red-pastel: #FFAAA5;

      /* UI Colors */
      --bg-primary: #FBF7F4;
      --bg-secondary: #FFFFFF;
      --text-primary: #5A5A6E;
      --text-secondary: #8E8EA0;
      --border-color: #E8E4E0;
      --shadow-soft: rgba(0, 0, 0, 0.04);
      --shadow-medium: rgba(0, 0, 0, 0.08);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #FBF7F4 0%, #F5F0EC 50%, #FBF7F4 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      gap: 20px;
      color: var(--text-primary);
    }

    #tetris {
      display: flex;
      gap: 24px;
      padding: 32px;
      background: var(--bg-secondary);
      border-radius: 24px;
      box-shadow:
        0 4px 24px var(--shadow-soft),
        0 1px 4px var(--shadow-medium);
      border: 1px solid var(--border-color);
    }

    #menu {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 140px;
    }

    .game-title {
      font-size: 1.5em;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.02em;
      text-align: center;
      margin-bottom: 8px;
    }

    #start {
      text-align: center;
      padding: 16px 20px;
      background: linear-gradient(135deg, var(--pastel-mint) 0%, var(--pastel-blue) 100%);
      border-radius: 12px;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    #start:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(174, 198, 207, 0.3);
    }

    #start a {
      text-decoration: none;
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.9em;
    }

    .next-piece-container {
      text-align: center;
    }

    .section-label {
      font-size: 0.75em;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 8px;
    }

    #upcoming {
      display: block;
      margin: 0 auto;
      background: linear-gradient(135deg, #FAFAFA 0%, #F5F5F5 100%);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    .stat-card {
      background: linear-gradient(135deg, #FAFAFA 0%, #FFFFFF 100%);
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      letter-spacing: -0.02em;
    }

    #score {
      color: var(--purple-pastel);
      background: linear-gradient(135deg, #D4A5E8 0%, #9BB8ED 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #rows {
      color: var(--cyan-pastel);
      background: linear-gradient(135deg, #A8E6CF 0%, #9BB8ED 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #canvas {
      display: block;
      background: linear-gradient(180deg, #FCFCFC 0%, #F8F8F8 100%);
      border-radius: 16px;
      border: 1px solid var(--border-color);
      box-shadow:
        inset 0 2px 8px rgba(0, 0, 0, 0.02),
        0 4px 16px var(--shadow-soft);
      background-image:
        linear-gradient(to right, rgba(0, 0, 0, 0.02) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0, 0, 0, 0.02) 1px, transparent 1px);
      background-size: 10% 5%;
    }

    .controls-hint {
      font-size: 0.7em;
      color: var(--text-secondary);
      text-align: center;
      margin-top: auto;
      line-height: 1.6;
    }

    .controls-hint kbd {
      display: inline-block;
      padding: 2px 6px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.9em;
    }

    /* Responsive Design */
    @media screen and (min-width: 0px) and (min-height: 0px) {
      #tetris {
        font-size: 0.75em;
      }

      #menu {
        min-width: 100px;
      }

      #upcoming,
      #hold-canvas {
        width: 50px;
        height: 50px;
      }

      #canvas {
        width: 100px;
        height: 200px;
      }
    }

    @media screen and (min-width: 400px) and (min-height: 400px) {
      #tetris {
        font-size: 0.85em;
      }

      #menu {
        min-width: 120px;
      }

      #upcoming,
      #hold-canvas {
        width: 60px;
        height: 60px;
      }

      #canvas {
        width: 130px;
        height: 260px;
      }
    }

    @media screen and (min-width: 500px) and (min-height: 500px) {
      #tetris {
        font-size: 1em;
      }

      #menu {
        min-width: 140px;
      }

      #upcoming,
      #hold-canvas {
        width: 80px;
        height: 80px;
      }

      #canvas {
        width: 160px;
        height: 320px;
      }
    }

    @media screen and (min-width: 600px) and (min-height: 600px) {
      #tetris {
        font-size: 1.1em;
      }

      #menu {
        min-width: 160px;
      }

      #upcoming,
      #hold-canvas {
        width: 100px;
        height: 100px;
      }

      #canvas {
        width: 200px;
        height: 400px;
      }
    }

    @media screen and (min-width: 700px) and (min-height: 700px) {
      #tetris {
        font-size: 1.2em;
      }

      #menu {
        min-width: 180px;
      }

      #upcoming,
      #hold-canvas {
        width: 110px;
        height: 110px;
      }

      #canvas {
        width: 240px;
        height: 480px;
      }
    }

    @media screen and (min-width: 800px) and (min-height: 800px) {
      #tetris {
        font-size: 1.3em;
      }

      #menu {
        min-width: 200px;
      }

      #upcoming,
      #hold-canvas {
        width: 130px;
        height: 130px;
      }

      #canvas {
        width: 280px;
        height: 560px;
      }
    }

    @media screen and (min-width: 900px) and (min-height: 900px) {
      #tetris {
        font-size: 1.4em;
      }

      #menu {
        min-width: 220px;
      }

      #upcoming,
      #hold-canvas {
        width: 150px;
        height: 150px;
      }

      #canvas {
        width: 320px;
        height: 640px;
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    #start.playing {
      animation: pulse 2s ease-in-out infinite;
    }

    /* Pause overlay */
    .pause-overlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(251, 247, 244, 0.85);
      border-radius: 16px;
      z-index: 10;
      justify-content: center;
      align-items: center;
      font-size: 1.4em;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 0.1em;
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
    }

    .pause-overlay.visible {
      display: flex;
    }

    /* Canvas wrapper for overlay positioning */
    .canvas-wrapper {
      position: relative;
    }

    /* New high score indicator */
    .new-hs {
      font-size: 0.65em;
      color: var(--red-pastel);
      font-weight: 600;
      letter-spacing: 0.04em;
      display: none;
      margin-top: 2px;
    }

    .new-hs.visible {
      display: block;
    }

    @keyframes line-flash {
      0% {
        opacity: 0;
      }

      40% {
        opacity: 0.9;
      }

      100% {
        opacity: 0;
      }
    }

    /* Hold preview */
    #hold-canvas {
      display: block;
      margin: 0 auto;
      background: linear-gradient(135deg, #FAFAFA 0%, #F5F5F5 100%);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    /* Touch button extras */
    .touch-btn-harddrop {
      grid-column: 1;
      grid-row: 2;
      background: linear-gradient(135deg, var(--pastel-coral) 0%, #F09A94 100%);
      color: #8A4A4A;
    }

    .touch-btn-hold {
      grid-column: 3;
      grid-row: 2;
      background: linear-gradient(135deg, var(--pastel-yellow) 0%, #F0E6A0 100%);
      color: #8A7A3A;
    }

    /* =========================================
       TOUCH CONTROLS - Mobile/Tablet Only
       ========================================= */

    #touch-controls {
      display: none;
      width: 100%;
      max-width: 400px;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 20px;
      box-shadow:
        0 4px 24px var(--shadow-soft),
        0 1px 4px var(--shadow-medium);
      border: 1px solid var(--border-color);
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #touch-controls.visible {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }

    .touch-controls-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 10px;
      max-width: 280px;
      margin: 0 auto;
    }

    .touch-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 60px;
      border: none;
      border-radius: 14px;
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .touch-btn:active {
      transform: scale(0.92);
    }

    .touch-btn-left {
      grid-column: 1;
      grid-row: 1;
      background: linear-gradient(135deg, var(--pastel-blue) 0%, #8BADD9 100%);
      color: #4A6B8A;
    }

    .touch-btn-rotate {
      grid-column: 2;
      grid-row: 1;
      background: linear-gradient(135deg, var(--pastel-lavender) 0%, #C9A0D0 100%);
      color: #7A5A82;
    }

    .touch-btn-right {
      grid-column: 3;
      grid-row: 1;
      background: linear-gradient(135deg, var(--pastel-blue) 0%, #8BADD9 100%);
      color: #4A6B8A;
    }

    .touch-btn-drop {
      grid-column: 2;
      grid-row: 2;
      background: linear-gradient(135deg, var(--pastel-mint) 0%, #8ED4B8 100%);
      color: #4A8A6B;
    }

    .touch-btn-play {
      grid-column: 1 / 4;
      grid-row: 1 / 3;
      background: linear-gradient(135deg, var(--pastel-mint) 0%, var(--pastel-blue) 100%);
      color: var(--text-primary);
      font-size: 18px;
    }

    .touch-btn-play.hidden {
      display: none;
    }

    .game-controls.hidden {
      display: none;
    }

    /* Responsive touch controls */
    @media screen and (max-width: 500px) {
      #touch-controls {
        max-width: 100%;
        border-radius: 16px;
      }

      .touch-btn {
        height: 55px;
        font-size: 22px;
      }
    }

    @media screen and (min-width: 600px) {
      .touch-btn {
        height: 70px;
        font-size: 28px;
      }
    }
  </style>
</head>

<body>
  <div id="tetris">
    <div id="menu">
      <h1 class="game-title">Tetris</h1>
      <p id="start"><a href="javascript:TetrisGame.play();">Press Enter to Play</a></p>

      <div class="next-piece-container">
        <p class="section-label">Hold</p>
        <canvas id="hold-canvas"></canvas>
      </div>

      <div class="next-piece-container">
        <p class="section-label">Next</p>
        <canvas id="upcoming"></canvas>
      </div>

      <div class="stat-card">
        <p class="section-label">Score</p>
        <p class="stat-value"><span id="score">00000</span></p>
      </div>

      <div class="stat-card">
        <p class="section-label">High Score</p>
        <p class="stat-value"><span id="high-score">00000</span></p>
        <p class="new-hs" id="new-hs-label">NEW HIGH SCORE!</p>
      </div>

      <div class="stat-card">
        <p class="section-label">Level</p>
        <p class="stat-value"><span id="level">1</span></p>
      </div>

      <div class="stat-card">
        <p class="section-label">Rows</p>
        <p class="stat-value"><span id="rows">0</span></p>
      </div>

      <div class="controls-hint">
        <kbd>←</kbd> <kbd>→</kbd> Move · <kbd>↑</kbd> Rotate<br>
        <kbd>↓</kbd> Soft Drop · <kbd>Space</kbd> Hard Drop<br>
        <kbd>C</kbd> Hold · <kbd>P</kbd> Pause<br>
        <kbd>Esc</kbd> End game
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="canvas">
        Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
      </canvas>
      <div class="pause-overlay" id="pause-overlay">PAUSED</div>
    </div>
  </div>

  <!-- Touch Controls for Mobile/Tablet -->
  <div id="touch-controls">
    <div class="touch-controls-grid">
      <button class="touch-btn touch-btn-play" id="touch-play">▶ TAP TO PLAY</button>
      <button class="touch-btn touch-btn-left game-controls hidden" id="touch-left">◀</button>
      <button class="touch-btn touch-btn-rotate game-controls hidden" id="touch-rotate">↻</button>
      <button class="touch-btn touch-btn-right game-controls hidden" id="touch-right">▶</button>
      <button class="touch-btn touch-btn-harddrop game-controls hidden" id="touch-harddrop">⤓</button>
      <button class="touch-btn touch-btn-drop game-controls hidden" id="touch-drop">▼</button>
      <button class="touch-btn touch-btn-hold game-controls hidden" id="touch-hold">⇄</button>
    </div>
  </div>

  <script>
    /**
     * Tetris Game - Refactored ES6+ Version
     * Fully offline, no external dependencies
     */

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const KEYS = Object.freeze({
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      ENTER: 13,
      P: 80,
      C: 67
    });

    const DIRECTIONS = Object.freeze({
      UP: 0,
      RIGHT: 1,
      DOWN: 2,
      LEFT: 3,
      MIN: 0,
      MAX: 3
    });

    const GAME_CONFIG = Object.freeze({
      COURT_WIDTH: 10,
      COURT_HEIGHT: 20,
      PREVIEW_SIZE: 5,
      SPEED: {
        START: 0.8,
        MIN: 0.05
      },
      SCORING: {
        DROP: 10,
        HARD_DROP_PER_ROW: 2,
        LINE_BASE: 100
      },
      ROWS_PER_LEVEL: 10,
      LINE_CLEAR_ANIM_MS: 300
    });

    // Tetromino definitions with pastel colors
    const TETROMINOES = Object.freeze({
      I: { size: 4, blocks: [0x0F00, 0x2222, 0x00F0, 0x4444], color: '#A8E6CF' },
      J: { size: 3, blocks: [0x44C0, 0x8E00, 0x6440, 0x0E20], color: '#9BB8ED' },
      L: { size: 3, blocks: [0x4460, 0x0E80, 0xC440, 0x2E00], color: '#FFD4A3' },
      O: { size: 2, blocks: [0xCC00, 0xCC00, 0xCC00, 0xCC00], color: '#FFF4B8' },
      S: { size: 3, blocks: [0x06C0, 0x8C40, 0x6C00, 0x4620], color: '#C7EECF' },
      T: { size: 3, blocks: [0x0E40, 0x4C40, 0x4E00, 0x4640], color: '#D4A5E8' },
      Z: { size: 3, blocks: [0x0C60, 0x4C80, 0xC600, 0x2640], color: '#FFAAA5' }
    });

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    const Utils = {
      /**
       * Get DOM element by ID
       * @param {string} id - Element ID
       * @returns {HTMLElement}
       */
      getElement(id) {
        return document.getElementById(id);
      },

      /**
       * Set element visibility
       * @param {string} id - Element ID
       * @param {boolean} visible - Whether element should be visible
       */
      setVisibility(id, visible) {
        this.getElement(id).style.visibility = visible ? 'visible' : 'hidden';
      },

      /**
       * Set element inner HTML
       * @param {string} id - Element ID
       * @param {string} content - HTML content
       */
      setHTML(id, content) {
        this.getElement(id).innerHTML = content;
      },

      /**
       * Get current timestamp
       * @returns {number}
       */
      now() {
        return performance.now();
      },

      /**
       * Generate random number in range
       * @param {number} min - Minimum value (inclusive)
       * @param {number} max - Maximum value (exclusive)
       * @returns {number}
       */
      random(min, max) {
        return min + Math.random() * (max - min);
      },

      /**
       * Format score with leading zeros
       * @param {number} score - Score value
       * @param {number} digits - Number of digits
       * @returns {string}
       */
      formatScore(score, digits = 5) {
        return String(Math.floor(score)).padStart(digits, '0');
      }
    };

    // =========================================================================
    // PIECE BAG - Random piece generator using 7-bag system
    // =========================================================================

    class PieceBag {
      constructor() {
        this.pieces = [];
        this.tetrominoTypes = Object.values(TETROMINOES);
      }

      /**
       * Refill bag with 4 copies of each piece (28 total)
       */
      refill() {
        this.pieces = [];
        for (const type of this.tetrominoTypes) {
          for (let i = 0; i < 4; i++) {
            this.pieces.push(type);
          }
        }
      }

      /**
       * Get next random piece from bag
       * @returns {{type: Object, dir: number, x: number, y: number}}
       */
      getNext() {
        if (this.pieces.length === 0) {
          this.refill();
        }

        const index = Math.floor(Utils.random(0, this.pieces.length));
        const type = this.pieces.splice(index, 1)[0];
        const maxX = GAME_CONFIG.COURT_WIDTH - type.size;

        return {
          type,
          dir: DIRECTIONS.UP,
          x: Math.round(Utils.random(0, maxX)),
          y: 0
        };
      }
    }

    // =========================================================================
    // GAME BOARD - Manages the playing field
    // =========================================================================

    class GameBoard {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.grid = [];
        this.clear();
      }

      /**
       * Clear the entire board
       */
      clear() {
        this.grid = Array.from({ length: this.width }, () =>
          Array(this.height).fill(null)
        );
      }

      /**
       * Get block at position
       * @param {number} x - X coordinate
       * @param {number} y - Y coordinate
       * @returns {Object|null}
       */
      getBlock(x, y) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
          return null;
        }
        return this.grid[x][y];
      }

      /**
       * Set block at position
       * @param {number} x - X coordinate
       * @param {number} y - Y coordinate
       * @param {Object|null} type - Block type or null to clear
       */
      setBlock(x, y, type) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
          this.grid[x][y] = type;
        }
      }

      /**
       * Check if position is occupied
       * @param {number} x - X coordinate
       * @param {number} y - Y coordinate
       * @returns {boolean}
       */
      isOccupied(x, y) {
        return x < 0 || x >= this.width || y < 0 || y >= this.height || this.getBlock(x, y) !== null;
      }

      /**
       * Check if a line is complete
       * @param {number} y - Row index
       * @returns {boolean}
       */
      isLineComplete(y) {
        for (let x = 0; x < this.width; x++) {
          if (!this.getBlock(x, y)) {
            return false;
          }
        }
        return true;
      }

      /**
       * Remove a line and shift everything above down
       * @param {number} lineY - Row index to remove
       */
      removeLine(lineY) {
        for (let y = lineY; y > 0; y--) {
          for (let x = 0; x < this.width; x++) {
            this.grid[x][y] = this.grid[x][y - 1];
          }
        }
        // Clear top row
        for (let x = 0; x < this.width; x++) {
          this.grid[x][0] = null;
        }
      }

      /**
       * Clear completed lines and return count
       * @returns {number} Number of lines cleared
       */
      clearCompletedLines() {
        let linesCleared = 0;

        for (let y = this.height - 1; y >= 0; y--) {
          if (this.isLineComplete(y)) {
            this.removeLine(y);
            y++; // Recheck this row since lines shifted down
            linesCleared++;
          }
        }

        return linesCleared;
      }
    }

    // =========================================================================
    // PIECE - Represents a tetromino piece
    // =========================================================================

    class Piece {
      /**
       * Iterate through each occupied block of a piece
       * @param {Object} type - Piece type
       * @param {number} x - X position
       * @param {number} y - Y position
       * @param {number} dir - Rotation direction
       * @param {Function} callback - Callback for each block (x, y)
       */
      static eachBlock(type, x, y, dir, callback) {
        const blocks = type.blocks[dir];
        let row = 0;
        let col = 0;

        for (let bit = 0x8000; bit > 0; bit >>= 1) {
          if (blocks & bit) {
            callback(x + col, y + row);
          }
          if (++col === 4) {
            col = 0;
            row++;
          }
        }
      }

      /**
       * Check if piece can occupy position
       * @param {GameBoard} board - Game board
       * @param {Object} type - Piece type
       * @param {number} x - X position
       * @param {number} y - Y position
       * @param {number} dir - Rotation direction
       * @returns {boolean}
       */
      static canOccupy(board, type, x, y, dir) {
        let canFit = true;

        this.eachBlock(type, x, y, dir, (bx, by) => {
          if (board.isOccupied(bx, by)) {
            canFit = false;
          }
        });

        return canFit;
      }
    }

    // =========================================================================
    // RENDERER - Handles all canvas drawing
    // =========================================================================

    class Renderer {
      constructor(mainCanvas, previewCanvas, holdCanvas, courtWidth, courtHeight, previewSize) {
        this.mainCanvas = mainCanvas;
        this.previewCanvas = previewCanvas;
        this.holdCanvas = holdCanvas;
        this.mainCtx = mainCanvas.getContext('2d');
        this.previewCtx = previewCanvas.getContext('2d');
        this.holdCtx = holdCanvas.getContext('2d');
        this.courtWidth = courtWidth;
        this.courtHeight = courtHeight;
        this.previewSize = previewSize;
        this.blockWidth = 0;
        this.blockHeight = 0;

        this.invalidFlags = {
          court: true, next: true, hold: true,
          score: true, rows: true, level: true, highScore: true
        };
      }

      resize() {
        this.mainCanvas.width = this.mainCanvas.clientWidth;
        this.mainCanvas.height = this.mainCanvas.clientHeight;
        this.previewCanvas.width = this.previewCanvas.clientWidth;
        this.previewCanvas.height = this.previewCanvas.clientHeight;
        this.holdCanvas.width = this.holdCanvas.clientWidth;
        this.holdCanvas.height = this.holdCanvas.clientHeight;

        this.blockWidth = this.mainCanvas.width / this.courtWidth;
        this.blockHeight = this.mainCanvas.height / this.courtHeight;
        this.invalidateAll();
      }

      invalidateAll() {
        for (const key in this.invalidFlags) this.invalidFlags[key] = true;
      }

      invalidate(area) {
        this.invalidFlags[area] = true;
      }

      drawBlock(ctx, x, y, color, alpha = 1) {
        const blockX = x * this.blockWidth;
        const blockY = y * this.blockHeight;
        const radius = Math.min(this.blockWidth, this.blockHeight) * 0.15;
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.roundRect(blockX + 1, blockY + 1, this.blockWidth - 2, this.blockHeight - 2, radius);
        ctx.fillStyle = color;
        ctx.fill();

        ctx.beginPath();
        ctx.roundRect(blockX + 2, blockY + 2, this.blockWidth - 4, this.blockHeight - 4, radius * 0.8);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fill();

        ctx.beginPath();
        ctx.roundRect(blockX + 1, blockY + 1, this.blockWidth - 2, this.blockHeight - 2, radius);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      drawPiece(ctx, type, x, y, dir, alpha = 1) {
        Piece.eachBlock(type, x, y, dir, (bx, by) => {
          this.drawBlock(ctx, bx, by, type.color, alpha);
        });
      }

      renderCourt(board, currentPiece, ghostY, isPlaying, flashRows) {
        if (!this.invalidFlags.court) return;
        const ctx = this.mainCtx;
        ctx.save();
        ctx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
        ctx.translate(0.5, 0.5);

        if (isPlaying && currentPiece) {
          // Ghost piece
          if (ghostY !== null && ghostY !== currentPiece.y) {
            this.drawPiece(ctx, currentPiece.type, currentPiece.x, ghostY, currentPiece.dir, 0.2);
          }
          // Current piece
          this.drawPiece(ctx, currentPiece.type, currentPiece.x, currentPiece.y, currentPiece.dir);
        }

        // Placed blocks
        for (let y = 0; y < this.courtHeight; y++) {
          for (let x = 0; x < this.courtWidth; x++) {
            const block = board.getBlock(x, y);
            if (block) {
              this.drawBlock(ctx, x, y, block.color);
            }
          }
        }

        // Line-clear flash overlay
        if (flashRows && flashRows.length > 0) {
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = '#FFFFFF';
          for (const row of flashRows) {
            ctx.fillRect(0, row * this.blockHeight, this.courtWidth * this.blockWidth, this.blockHeight);
          }
          ctx.globalAlpha = 1;
        }

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.strokeRect(0, 0, this.courtWidth * this.blockWidth - 1, this.courtHeight * this.blockHeight - 1);
        ctx.restore();
        this.invalidFlags.court = false;
      }

      renderPreview(ctx, canvas, piece, flagKey) {
        if (!this.invalidFlags[flagKey] || !piece) return;
        const padding = (this.previewSize - piece.type.size) / 2;
        ctx.save();
        ctx.translate(0.5, 0.5);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.drawPiece(ctx, piece.type, padding, padding, DIRECTIONS.UP);
        ctx.restore();
        this.invalidFlags[flagKey] = false;
      }

      renderNext(nextPiece) {
        this.renderPreview(this.previewCtx, this.previewCanvas, nextPiece, 'next');
      }

      renderHold(holdPiece) {
        if (!this.invalidFlags.hold) return;
        const ctx = this.holdCtx;
        ctx.save();
        ctx.clearRect(0, 0, this.holdCanvas.width, this.holdCanvas.height);
        if (holdPiece) {
          const padding = (this.previewSize - holdPiece.size) / 2;
          ctx.translate(0.5, 0.5);
          this.drawPiece(ctx, holdPiece, padding, padding, DIRECTIONS.UP);
        }
        ctx.restore();
        this.invalidFlags.hold = false;
      }

      renderScore(score) {
        if (!this.invalidFlags.score) return;
        Utils.setHTML('score', Utils.formatScore(score));
        this.invalidFlags.score = false;
      }

      renderHighScore(hs) {
        if (!this.invalidFlags.highScore) return;
        Utils.setHTML('high-score', Utils.formatScore(hs));
        this.invalidFlags.highScore = false;
      }

      renderRows(rows) {
        if (!this.invalidFlags.rows) return;
        Utils.setHTML('rows', rows);
        this.invalidFlags.rows = false;
      }

      renderLevel(level) {
        if (!this.invalidFlags.level) return;
        Utils.setHTML('level', level);
        this.invalidFlags.level = false;
      }

      render(board, currentPiece, nextPiece, holdPiece, ghostY, score, rows, level, highScore, isPlaying, flashRows) {
        this.renderCourt(board, currentPiece, ghostY, isPlaying, flashRows);
        this.renderNext(nextPiece);
        this.renderHold(holdPiece);
        this.renderScore(score);
        this.renderHighScore(highScore);
        this.renderRows(rows);
        this.renderLevel(level);
      }
    }

    // =========================================================================
    // INPUT HANDLER - Manages keyboard input
    // =========================================================================

    class InputHandler {
      constructor(onAction, onPlay) {
        this.actionQueue = [];
        this.onAction = onAction;
        this.onPlay = onPlay;
        this.isPlaying = false;
        this.handleKeydown = this.handleKeydown.bind(this);
      }
      start() { document.addEventListener('keydown', this.handleKeydown, false); }
      stop() { document.removeEventListener('keydown', this.handleKeydown, false); }
      setPlaying(p) { this.isPlaying = p; }
      clearActions() { this.actionQueue = []; }
      getNextAction() { return this.actionQueue.shift(); }

      handleKeydown(event) {
        let handled = false;
        if (this.isPlaying) {
          switch (event.keyCode) {
            case KEYS.LEFT: this.actionQueue.push(DIRECTIONS.LEFT); handled = true; break;
            case KEYS.RIGHT: this.actionQueue.push(DIRECTIONS.RIGHT); handled = true; break;
            case KEYS.UP: this.actionQueue.push(DIRECTIONS.UP); handled = true; break;
            case KEYS.DOWN: this.actionQueue.push(DIRECTIONS.DOWN); handled = true; break;
            case KEYS.SPACE: this.onAction('hardDrop'); handled = true; break;
            case KEYS.C: this.onAction('hold'); handled = true; break;
            case KEYS.P: this.onAction('pause'); handled = true; break;
            case KEYS.ESC: this.onAction('lose'); handled = true; break;
          }
        } else {
          if (event.keyCode === KEYS.ENTER || event.keyCode === KEYS.SPACE) {
            this.onPlay(); handled = true;
          }
          if (event.keyCode === KEYS.P) { this.onAction('pause'); handled = true; }
        }
        if (handled) event.preventDefault();
      }
    }

    // =========================================================================
    // GAME ENGINE - Main game controller
    // =========================================================================

    class TetrisEngine {
      constructor() {
        this.board = new GameBoard(GAME_CONFIG.COURT_WIDTH, GAME_CONFIG.COURT_HEIGHT);
        this.pieceBag = new PieceBag();
        this.renderer = new Renderer(
          Utils.getElement('canvas'),
          Utils.getElement('upcoming'),
          Utils.getElement('hold-canvas'),
          GAME_CONFIG.COURT_WIDTH,
          GAME_CONFIG.COURT_HEIGHT,
          GAME_CONFIG.PREVIEW_SIZE
        );
        this.input = new InputHandler(
          (action) => this.handleGameAction(action),
          () => this.play()
        );

        this.isPlaying = false;
        this.isPaused = false;
        this.score = 0;
        this.visualScore = 0;
        this.rows = 0;
        this.level = 1;
        this.dropInterval = GAME_CONFIG.SPEED.START;
        this.dropTimer = 0;
        this.currentPiece = null;
        this.nextPiece = null;
        this.holdPieceType = null;
        this.hasSwappedThisTurn = false;
        this.ghostY = null;
        this.highScore = parseInt(localStorage.getItem('tetris-high-score') || '0', 10);
        this.isNewHighScore = false;
        this.flashRows = [];
        this.flashTimer = 0;
        this.isFlashing = false;
        this.lastTimestamp = 0;
        this.animationId = null;

        this.gameLoop = this.gameLoop.bind(this);
        this.handleResize = this.handleResize.bind(this);
      }

      init() {
        this.input.start();
        window.addEventListener('resize', this.handleResize, false);
        this.handleResize();
        this.reset();
        this.renderer.invalidate('highScore');
        this.lastTimestamp = Utils.now();
        this.gameLoop();
      }

      handleResize() { this.renderer.resize(); }

      calcSpeed(level) {
        return Math.max(GAME_CONFIG.SPEED.MIN, GAME_CONFIG.SPEED.START - (level - 1) * 0.07);
      }

      reset() {
        this.dropTimer = 0;
        this.board.clear();
        this.input.clearActions();
        this.holdPieceType = null;
        this.hasSwappedThisTurn = false;
        this.isNewHighScore = false;
        this.flashRows = [];
        this.isFlashing = false;
        this.isPaused = false;
        Utils.getElement('pause-overlay').classList.remove('visible');
        Utils.getElement('new-hs-label').classList.remove('visible');
        this.setRows(0);
        this.setScore(0);
        this.currentPiece = this.nextPiece || this.pieceBag.getNext();
        this.nextPiece = this.pieceBag.getNext();
        this.updateGhost();
        this.renderer.invalidateAll();
      }

      play() {
        if (this.isPaused) return;
        Utils.setVisibility('start', false);
        this.reset();
        this.isPlaying = true;
        this.input.setPlaying(true);
      }

      lose() {
        Utils.setVisibility('start', true);
        this.visualScore = this.score;
        this.renderer.invalidate('score');
        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('tetris-high-score', String(this.highScore));
          this.isNewHighScore = true;
          Utils.getElement('new-hs-label').classList.add('visible');
          this.renderer.invalidate('highScore');
        }
        this.isPlaying = false;
        this.isPaused = false;
        Utils.getElement('pause-overlay').classList.remove('visible');
        this.input.setPlaying(false);
      }

      togglePause() {
        if (!this.isPlaying && !this.isPaused) return;
        this.isPaused = !this.isPaused;
        const overlay = Utils.getElement('pause-overlay');
        if (this.isPaused) {
          overlay.classList.add('visible');
          this.input.setPlaying(false);
        } else {
          overlay.classList.remove('visible');
          this.input.setPlaying(true);
          this.lastTimestamp = Utils.now();
        }
      }

      handleGameAction(action) {
        switch (action) {
          case 'lose': this.lose(); break;
          case 'hardDrop': this.hardDrop(); break;
          case 'hold': this.hold(); break;
          case 'pause': this.togglePause(); break;
        }
      }

      setScore(value) {
        this.score = value;
        this.visualScore = value;
        this.renderer.invalidate('score');
      }

      addScore(value) { this.score += value; }

      setRows(value) {
        this.rows = value;
        this.level = Math.floor(value / GAME_CONFIG.ROWS_PER_LEVEL) + 1;
        this.dropInterval = this.calcSpeed(this.level);
        this.renderer.invalidate('rows');
        this.renderer.invalidate('level');
      }

      addRows(value) { this.setRows(this.rows + value); }

      updateGhost() {
        if (!this.currentPiece) { this.ghostY = null; return; }
        let gy = this.currentPiece.y;
        while (Piece.canOccupy(this.board, this.currentPiece.type, this.currentPiece.x, gy + 1, this.currentPiece.dir)) {
          gy++;
        }
        this.ghostY = gy;
      }

      movePiece(direction) {
        let { x, y } = this.currentPiece;
        switch (direction) {
          case DIRECTIONS.LEFT: x -= 1; break;
          case DIRECTIONS.RIGHT: x += 1; break;
          case DIRECTIONS.DOWN: y += 1; break;
        }
        if (Piece.canOccupy(this.board, this.currentPiece.type, x, y, this.currentPiece.dir)) {
          this.currentPiece.x = x;
          this.currentPiece.y = y;
          this.updateGhost();
          this.renderer.invalidate('court');
          return true;
        }
        return false;
      }

      rotatePiece() {
        const newDir = this.currentPiece.dir === DIRECTIONS.MAX ? DIRECTIONS.MIN : this.currentPiece.dir + 1;
        if (Piece.canOccupy(this.board, this.currentPiece.type, this.currentPiece.x, this.currentPiece.y, newDir)) {
          this.currentPiece.dir = newDir;
          this.updateGhost();
          this.renderer.invalidate('court');
        }
      }

      hardDrop() {
        if (this.isFlashing) return;
        this.updateGhost();
        const rowsDropped = this.ghostY - this.currentPiece.y;
        this.currentPiece.y = this.ghostY;
        this.addScore(rowsDropped * GAME_CONFIG.SCORING.HARD_DROP_PER_ROW);
        this.lockAndAdvance();
      }

      hold() {
        if (this.hasSwappedThisTurn || this.isFlashing) return;
        this.hasSwappedThisTurn = true;
        const curType = this.currentPiece.type;
        if (this.holdPieceType) {
          const maxX = GAME_CONFIG.COURT_WIDTH - this.holdPieceType.size;
          this.currentPiece = {
            type: this.holdPieceType,
            dir: DIRECTIONS.UP,
            x: Math.min(this.currentPiece.x, maxX),
            y: 0
          };
        } else {
          this.currentPiece = this.nextPiece;
          this.nextPiece = this.pieceBag.getNext();
          this.renderer.invalidate('next');
        }
        this.holdPieceType = curType;
        this.updateGhost();
        this.renderer.invalidate('hold');
        this.renderer.invalidate('court');
        if (!Piece.canOccupy(this.board, this.currentPiece.type, this.currentPiece.x, this.currentPiece.y, this.currentPiece.dir)) {
          this.lose();
        }
      }

      lockAndAdvance() {
        this.lockPiece();
        const completedLines = [];
        for (let y = this.board.height - 1; y >= 0; y--) {
          if (this.board.isLineComplete(y)) completedLines.push(y);
        }
        if (completedLines.length > 0) {
          this.flashRows = completedLines;
          this.flashTimer = 0;
          this.isFlashing = true;
          this.renderer.invalidate('court');
        } else {
          this.advanceToNextPiece();
        }
      }

      advanceToNextPiece() {
        const linesCleared = this.flashRows.length;
        if (linesCleared > 0) {
          this.board.clearCompletedLines();
          this.addRows(linesCleared);
          this.addScore(GAME_CONFIG.SCORING.LINE_BASE * Math.pow(2, linesCleared - 1));
        }
        this.flashRows = [];
        this.isFlashing = false;
        this.currentPiece = this.nextPiece;
        this.nextPiece = this.pieceBag.getNext();
        this.hasSwappedThisTurn = false;
        this.input.clearActions();
        this.updateGhost();
        this.renderer.invalidate('next');
        this.renderer.invalidate('court');
        if (!Piece.canOccupy(this.board, this.currentPiece.type, this.currentPiece.x, this.currentPiece.y, this.currentPiece.dir)) {
          this.lose();
        }
      }

      dropPiece() {
        if (this.isFlashing) return;
        if (!this.movePiece(DIRECTIONS.DOWN)) {
          this.addScore(GAME_CONFIG.SCORING.DROP);
          this.lockAndAdvance();
        }
      }

      lockPiece() {
        Piece.eachBlock(this.currentPiece.type, this.currentPiece.x, this.currentPiece.y, this.currentPiece.dir, (x, y) => {
          this.board.setBlock(x, y, this.currentPiece.type);
        });
        this.renderer.invalidate('court');
      }

      processAction(action) {
        if (this.isFlashing) return;
        switch (action) {
          case DIRECTIONS.LEFT: this.movePiece(DIRECTIONS.LEFT); break;
          case DIRECTIONS.RIGHT: this.movePiece(DIRECTIONS.RIGHT); break;
          case DIRECTIONS.UP: this.rotatePiece(); break;
          case DIRECTIONS.DOWN: this.dropPiece(); break;
        }
      }

      update(deltaTime) {
        if (!this.isPlaying || this.isPaused) return;
        if (this.isFlashing) {
          this.flashTimer += deltaTime * 1000;
          this.renderer.invalidate('court');
          if (this.flashTimer >= GAME_CONFIG.LINE_CLEAR_ANIM_MS) {
            this.advanceToNextPiece();
          }
          return;
        }
        if (this.visualScore < this.score) {
          this.visualScore = Math.min(this.score, this.visualScore + 1);
          this.renderer.invalidate('score');
        }
        const action = this.input.getNextAction();
        if (action !== undefined) this.processAction(action);
        this.dropTimer += deltaTime;
        if (this.dropTimer >= this.dropInterval) {
          this.dropTimer -= this.dropInterval;
          this.dropPiece();
        }
      }

      gameLoop() {
        const currentTime = Utils.now();
        const deltaTime = Math.min(1, (currentTime - this.lastTimestamp) / 1000);
        this.lastTimestamp = currentTime;
        this.update(deltaTime);
        this.renderer.render(
          this.board, this.currentPiece, this.nextPiece,
          this.holdPieceType, this.ghostY, this.visualScore,
          this.rows, this.level, this.highScore, this.isPlaying,
          this.isFlashing ? this.flashRows : null
        );
        this.animationId = requestAnimationFrame(this.gameLoop);
      }
    }

    // =========================================================================
    // TOUCH CONTROLS - Mobile/Tablet Detection & Handler
    // =========================================================================

    class TouchControls {
      constructor(game) {
        this.game = game;
        this.container = Utils.getElement('touch-controls');
        this.playBtn = Utils.getElement('touch-play');
        this.leftBtn = Utils.getElement('touch-left');
        this.rotateBtn = Utils.getElement('touch-rotate');
        this.rightBtn = Utils.getElement('touch-right');
        this.dropBtn = Utils.getElement('touch-drop');
        this.hardDropBtn = Utils.getElement('touch-harddrop');
        this.holdBtn = Utils.getElement('touch-hold');
        this.gameControls = document.querySelectorAll('.game-controls');
        this.isVisible = false;

        this.bindEvents();
      }

      /**
       * Detect if device is mobile or tablet
       * @returns {boolean}
       */
      static isMobileOrTablet() {
        // Check for touch capability
        const hasTouch = 'ontouchstart' in window ||
          navigator.maxTouchPoints > 0 ||
          navigator.msMaxTouchPoints > 0;

        // Check user agent for mobile/tablet keywords
        const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet/i;
        const isMobileUA = mobileRegex.test(navigator.userAgent);

        // Check screen size (tablets typically < 1024px)
        const isSmallScreen = window.innerWidth <= 1024;

        // Consider it mobile/tablet if has touch AND (mobile UA OR small screen)
        return hasTouch && (isMobileUA || isSmallScreen);
      }

      /**
       * Show touch controls with animation
       */
      show() {
        if (this.isVisible) return;
        this.isVisible = true;
        this.container.classList.add('visible');
      }

      /**
       * Hide touch controls
       */
      hide() {
        this.isVisible = false;
        this.container.classList.remove('visible');
      }

      /**
       * Update control visibility based on game state
       * @param {boolean} isPlaying - Whether game is active
       */
      updateGameState(isPlaying) {
        if (isPlaying) {
          this.playBtn.classList.add('hidden');
          this.gameControls.forEach(btn => btn.classList.remove('hidden'));
        } else {
          this.playBtn.classList.remove('hidden');
          this.gameControls.forEach(btn => btn.classList.add('hidden'));
        }
      }

      /**
       * Bind touch event listeners
       */
      bindEvents() {
        // Prevent context menu on long press
        this.container.addEventListener('contextmenu', e => e.preventDefault());

        // Play button
        this.playBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.play();
          this.updateGameState(true);
        }, { passive: false });

        // Movement buttons with touch events
        this.leftBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.input.actionQueue.push(DIRECTIONS.LEFT);
        }, { passive: false });

        this.rightBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.input.actionQueue.push(DIRECTIONS.RIGHT);
        }, { passive: false });

        this.rotateBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.input.actionQueue.push(DIRECTIONS.UP);
        }, { passive: false });

        this.dropBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.input.actionQueue.push(DIRECTIONS.DOWN);
        }, { passive: false });

        this.hardDropBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.handleGameAction('hardDrop');
        }, { passive: false });

        this.holdBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.game.handleGameAction('hold');
        }, { passive: false });
      }

      /**
       * Auto-detect and show controls if on mobile/tablet
       * Called within 100ms of page load
       */
      autoDetect() {
        if (TouchControls.isMobileOrTablet()) {
          this.show();
          // Hide keyboard hints on mobile
          const keyboardHints = document.querySelector('.controls-hint');
          if (keyboardHints) {
            keyboardHints.style.display = 'none';
          }
        }
      }
    }

    // =========================================================================
    // INITIALIZE GAME
    // =========================================================================

    const TetrisGame = new TetrisEngine();
    TetrisGame.init();

    // Initialize touch controls and auto-detect within 100ms
    const touchControls = new TouchControls(TetrisGame);

    // Auto-detect mobile/tablet and show controls within 100ms
    setTimeout(() => {
      touchControls.autoDetect();
    }, 50); // 50ms < 100ms requirement

    // Sync touch controls with game state changes
    const originalLose = TetrisGame.lose.bind(TetrisGame);
    TetrisGame.lose = function () {
      originalLose();
      touchControls.updateGameState(false);
    };
  </script>
</body>

</html>